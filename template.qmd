---
title: "Project"
subtitle: "Precipitation Downscaling"
jupyter: julia-1.9
date: 2023-11-13
author: "Kyle Ostlind(ko23)" # UNCOMMENT AND ADD YOUR NAME

number-sections: true
code-annotations: hover

kind: "Lab"
Module: "2"
categories:
    - "Module 2"
    - "Labs"

format:
    html: 
        toc-depth: 3
    docx: 
        toc: true
        toc-depth: 3
        fig-format: png
---



```{julia}
#| output: false
using Dates
using MultivariateStats
using Plots
using NCDatasets
using StatsBase
using Unitful
using Distances
```

# Data

## Precipitation


```{julia}
precip_ds = NCDataset("data/precip_tx.nc")
precip_time = precip_ds["time"][:]
precip_lon = precip_ds["lon"][:]
precip_lat = precip_ds["lat"][:]
precip = precip_ds["precip"][:, :, :]
```

```{julia}
precip_lat = reverse(precip_lat)
precip = reverse(precip; dims=2)

precip = reverse(precip; dims=2)
#precip = replace(precip, missing=>NaN)
#display(precip_ds[:precip]) # learn about it
close(precip_ds)

```

```{julia}
heatmap(
precip_lon,
precip_lat,
precip[:, :, 2]';
xlabel="Longitude",
ylabel="Latitude",
title="Precipitation on $(precip_time[1])"
)
```
```{julia}
#cut down precip data to fit temp data size 
idx = findfirst(precip_time .== Dates.Date("2000-01-01"))
idx2 = findfirst(precip_time .== Dates.Date("2022-12-31"))
precip_time_cut = precip_time[idx:idx2]
```

```{julia}
#open files and extract data into NCdataset and/or Dictionaries 
data_dict1 = open_mfdataset(["data/raw/2m_temperature_2000.nc", "data/raw/2m_temperature_2001.nc", "data/raw/2m_temperature_2002.nc","data/raw/2m_temperature_2003.nc","data/raw/2m_temperature_2004.nc","data/raw/2m_temperature_2005.nc","data/raw/2m_temperature_2006.nc","data/raw/2m_temperature_2007.nc","data/raw/2m_temperature_2008.nc","data/raw/2m_temperature_2009.nc","data/raw/2m_temperature_2010.nc","data/raw/2m_temperature_2011.nc","data/raw/2m_temperature_2012.nc","data/raw/2m_temperature_2013.nc","data/raw/2m_temperature_2014.nc","data/raw/2m_temperature_2015.nc","data/raw/2m_temperature_2016.nc","data/raw/2m_temperature_2017.nc","data/raw/2m_temperature_2018.nc","data/raw/2m_temperature_2019.nc","data/raw/2m_temperature_2020.nc","data/raw/2m_temperature_2021.nc","data/raw/2m_temperature_2022.nc"], "t2m")

println(length(data_dict1[:"time"]))
println(length(data_dict1[:"t2m"]))
# # data_dict1 = open_mfdataset(["data/raw/2m_temperature_2019.nc"], "t2m")
temp_ds = NCDataset("data/raw/2m_temperature_2019.nc")
press_ds = NCDataset("data/raw/500hPa_geopotential_2019.nc")
```

```{julia}
#reshape and correct data 

dataTemp = reshape(data_dict1[:"t2m"],13, 13,length(data_dict1[:"time"]))
println(length(dataTemp[:,:,1]))

temp_lat = reverse(temp_ds[:"latitude"])
temp_lon = temp_ds[:"longitude"]
temp = reverse(dataTemp; dims=2)
println(length(data_dict1[:"time"]))


temp_time = temp_ds["time"][:]
press_time = press_ds["time"][:]

# #check the form of the data 
heatmap(
temp_lon,
temp_lat,
dataTemp[:, :, 1]';
xlabel="Longitude",
ylabel="Latitude",
title="Temperature on hour 1"
)

```



```{julia}
#average by day to match the precip data 
temp_byDay = reshape(dataTemp, length(temp_lat), length(temp_lat), 24, 8401)
daily_mean = mean(temp_byDay, dims=3)
temp_byDay = reshape(daily_mean,length(temp_lat),length(temp_lat),84)
```

```{julia}
dataPress = reshape(press_ds[:"z"],13, 13,length(press_ds[:"time"]))
#check form of data 
heatmap(
data_dict1[:"longitude"],
temp_lat,
dataPress[:, :, 1]';
xlabel="Longitude",
ylabel="Latitude",
title="Temperature on hour 1"
)
```

```{julia}
#check time and convert to Date data type 
@assert temp_time == press_time
time1 = Dates.Date.(temp_time)
time_p = Dates.Date.(precip_time_cut)
size(time1)
```

```{julia}
idx_partition = findfirst(time_p .== time_p[end] - Dates.Day(5544))

#split the data 150 days from end of data just for one year of data, may need to create a different partition later 

train_idx = 1:idx_partition
test_idx = (idx_partition+1):length(time_p)
precip_train = precip[:, :, train_idx]
precip_test = precip[:, :, test_idx]
temp_train = temp_byDay[:, :, train_idx]
temp_test = temp_byDay[:, :, test_idx]

```

```{julia}
function preprocess(temp::Array{T,3}, temp_ref::Array{T,3})::AbstractMatrix where {T}
    n_lon, n_lat, n_t = size(temp)
    println(n_lon)
    println(n_lat)
    println(n_t)
    climatology = mean(temp_ref; dims=3)
    temp_anom = temp .- climatology
    # reshape to 2D
    temp_anom = reshape(temp_anom, n_lon * n_lat, n_t)
    # strip the units
    return temp_anom
end
```

```{julia}
n_lon, n_lat, n_t = size(temp)
temp_mat_train = preprocess(temp_train, temp_train)
temp_mat_test = preprocess(temp_test, temp_train)
```

```{julia}
pca_model = fit(PCA, temp_mat_train; maxoutdim=25, pratio=0.999);
```

```{julia}
p1 = plot(
principalvars(pca_model) / var(pca_model);
xlabel="# of PCs",
ylabel="Fraction of Variance Explained",
xticks = 0:2:25,
label=false,
title="Variance Explained"
)
p2 = plot(
cumsum(principalvars(pca_model)) / var(pca_model);
xlabel="# of PCs",
ylabel="Fraction of Variance Explained",
xticks = 0:2:25,
label=false,
title="Cumulative Variance Explained Plot"
)
plot(p1, p2; layout=(1, 2), size=(800, 400))

```

```{julia}
p = []
for i in 1:3
pc = projection(pca_model)[:, i]
pc = reshape(pc, n_lat, n_lon)'
pi = heatmap(
temp_lon,
temp_lat,
pc;
xlabel="Longitude",
ylabel="Latitude",
title="PC $i",
aspect_ratio=:equal,
cmap=:PuOr
)
push!(p, pi)
end
plot(p...; layout=(1, 3), size=(1500, 600))

```

```{julia}
pc_ts = predict(pca_model, temp_mat_train)
day_of_year = Dates.dayofyear.(time1)
p = []
for i in 1:3
pi = scatter(
day_of_year,
pc_ts[i, :];
xlabel="Day of Year",
ylabel="PC $i",
title="PC $i",
label=false,
alpha=0.3,
color=:gray
)
push!(p, pi)
end
plot(p...; layout=(1, 3), size=(1500, 600))
```

```{julia}
avg_precip = [mean(skipmissing(precip_train[:, :, t])) for t in 1:size(precip_train, 3)]
# ustrip.(
# u"inch", [mean(skipmissing(precip_train[:, :, t])) for t in 1:size(precip_train, 3)]
# )
# there is one weird NaN value
avg_precip = replace(avg_precip, NaN => 0)
p1 = scatter(
pc_ts[2, :],
pc_ts[3, :];
zcolor=avg_precip,
xlabel="PC 2",
ylabel="PC 3",
markersize=3,
clims=(0, 2.75),
title="All Days",
label=false
)
p2_idx = findall(avg_precip .> quantile(avg_precip, 0.98))
p2 = scatter(
pc_ts[2, p2_idx],
pc_ts[3, p2_idx];
zcolor=avg_precip[p2_idx],
xlabel="PC 2",
ylabel="PC 3",
markersize=5,
clims=(0, 2.75),
title="Rainy Days",
label=false
)
plot(p1, p2; size=(1000, 400), link=:both)

```

```{julia}
function euclidean_distance(x::AbstractVector, y::AbstractVector)::AbstractFloat
    return sqrt(sum((x .- y) .^ 2))
end
function nsmallest(x::AbstractVector, n::Int)::Vector{Int}
    idx = sortperm(x)
    return idx[1:n]
end
function knn(X::AbstractMatrix, X_i::AbstractVector, K::Int)::Tuple{Int,AbstractVector}
# calculate the distances between X_i and each row of X
    dist = [euclidean_distance(X_i, X[j, :]) for j in 1:size(X, 1)]
    idx = nsmallest(dist, K)
    w = 1 ./ dist[idx]
    w ./= sum(w)
    idx_sample = sample(idx, Weights(w))
    return (idx_sample, vec(X[idx_sample, :]))
end
```

```{julia}
function predict_knn(temp_train, temp_test, precip_train; n_pca::Int)
    X_train = preprocess(temp_train, temp_train)
    X_test = preprocess(temp_test, temp_train)
    # fit the PCA model to the training data
    pca_model = fit(PCA, X_train; maxoutdim=n_pca)
    # project the test data onto the PCA basis
    train_embedded = predict(pca_model, X_train)
    test_embedded = predict(pca_model, X_test)
    # use the `knn` function for each point in the test data
    precip_pred = map(1:size(X_test, 2)) do i
    idx, _ = knn(train_embedded', test_embedded[:, i], 3)
    precip_train[:, :, idx]
end
# return a matrix of predictions
return precip_pred
end
```

```{julia}
    t_sample = rand(1:size(temp_test, 3), 3)
    precip_pred = predict_knn(temp_train, temp_test[:, :, t_sample], precip_train; n_pca=3)
    p = map(eachindex(t_sample)) do ti
    t = t_sample[ti]
    y_pred = precip_pred[ti]'
    y_actual = precip_test[:, :, t]'
    
    cmax = max(maximum(skipmissing(y_pred)), maximum(skipmissing(y_actual)))
    #cmax = ustrip(u"mm", cmax)
    println(size(y_pred))
    p1 = heatmap(
    precip_lon,
    precip_lat,
    y_pred;
    xlabel="Longitude",
    ylabel="Latitude",
    title="Predicted",
    aspect_ratio=:equal,
    clims=(0, cmax)
    )
 
    p2 = heatmap(
    precip_lon,
    precip_lat,
    y_actual;
    xlabel="Longitude",
    ylabel="Latitude",
    title="Actual",
    aspect_ratio=:equal,
    clims=(0, cmax)
    )

    plot(p1, p2; layout=(2, 1), size=(1000, 400))
    end

    plot(p...; layout=(2, 3), size=(800, 400))

```

```{julia}
precip_pred_QQ = predict_knn(temp_train, temp_test[:, :, 23:24], precip_train; n_pca=3)
```

```{julia}
#quantile-quantile mapping
y_pred_QQ = precip_pred_QQ[1]'
display(y_pred_QQ)
y_actual_QQ = precip_test[:, :, 23]
y_pred_corrected = reshape(y_pred_QQ,length(precip_lon)*length(precip_lat))

for i in skipmissing(y_pred_corrected)
        point_quant = searchsortedfirst(sort(y_pred_corrected), i) / length(y_pred_corrected)
        quant_actual = quantile(skipmissing(y_actual_QQ),point_quant)
        idx = findfirst(x -> x == i, skipmissing(y_pred_corrected))
        y_pred_corrected[idx] = quant_actual

end
y_pred_corrected = reshape(y_pred_corrected,length(precip_lon), length(precip_lat))


```

```{julia}
y_pred_QQ = precip_pred_QQ[1]
display(y_pred_QQ)
```


```{julia}

plot1 = heatmap(
precip_lon,
precip_lat,
y_pred_corrected;
xlabel="Longitude",
ylabel="Latitude",
title="corrected",
xticks = 250:5:270,
aspect_ratio=:equal,
)

plot2 = heatmap(
precip_lon,
precip_lat,
y_pred;
xlabel="Longitude",
ylabel="Latitude",
title="predicted",
xticks = 250:5:270,
aspect_ratio=:equal,
)

plot3 = heatmap(
precip_lon,
precip_lat,
y_actual_QQ';
xlabel="Longitude",
ylabel="Latitude",
title="Actual",
xticks = 250:5:270,
aspect_ratio=:equal,
)

plot(plot1,plot2,plot3; layout=(1, 3),size=(800, 400))

```

```{julia}
#quantile - quantile mapping part 2 lol
println(size(temp_byDay[:,:,1]))
println(length(temp_lon))
println(length(temp_lon))
temp_mat = reshape(temp_byDay[:,:,1],length(temp_lon)*length(temp_lat))
qq_pred = []
for i in skipmissing(temp_mat)
        point_quant = searchsortedfirst(sort(temp_mat), i) / length(temp_mat)
        quant_actual = quantile(skipmissing(y_actual),point_quant)
        idx = findfirst(x -> x == i, skipmissing(temp_mat))
        append!(qq_pred,quant_actual)
end

qq_pred = reshape(qq_pred, length(precip_lon),length(precip_lat))
```